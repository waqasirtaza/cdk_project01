"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = void 0;
const stream_1 = require("stream");
const AWS = require("aws-sdk");
const util_1 = require("../../util");
const evaluate_cloudformation_template_1 = require("../evaluate-cloudformation-template");
const common_1 = require("./common");
// namespace object imports won't work in the bundle for function exports
// eslint-disable-next-line @typescript-eslint/no-require-imports
const archiver = require('archiver');
/**
 * Returns `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change cannot be short-circuited,
 * `ChangeHotswapImpact.IRRELEVANT` if the change is irrelevant from a short-circuit perspective
 * (like a change to CDKMetadata),
 * or a LambdaFunctionResource if the change can be short-circuited.
 */
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    // if the change is for a Lambda Version,
    // ignore it by returning an empty hotswap operation -
    // we will publish a new version when we get to hotswapping the actual Function this Version points to, below
    // (Versions can't be changed in CloudFormation anyway, they're immutable)
    if (change.newValue.Type === 'AWS::Lambda::Version') {
        return common_1.ChangeHotswapImpact.IRRELEVANT;
    }
    // we handle Aliases specially too
    if (change.newValue.Type === 'AWS::Lambda::Alias') {
        return checkAliasHasVersionOnlyChange(change);
    }
    const lambdaCodeChange = await isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate);
    if (typeof lambdaCodeChange === 'string') {
        return lambdaCodeChange;
    }
    const functionName = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, change.newValue.Properties?.FunctionName);
    if (!functionName) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const functionArn = await evaluateCfnTemplate.evaluateCfnExpression({
        'Fn::Sub': 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:' + functionName,
    });
    // find all Lambda Versions that reference this Function
    const versionsReferencingFunction = evaluateCfnTemplate.findReferencesTo(logicalId)
        .filter(r => r.Type === 'AWS::Lambda::Version');
    // find all Lambda Aliases that reference the above Versions
    const aliasesReferencingVersions = util_1.flatMap(versionsReferencingFunction, v => evaluateCfnTemplate.findReferencesTo(v.LogicalId));
    const aliasesNames = await Promise.all(aliasesReferencingVersions.map(a => evaluateCfnTemplate.evaluateCfnExpression(a.Properties?.Name)));
    return new LambdaFunctionHotswapOperation({
        physicalName: functionName,
        functionArn: functionArn,
        resource: lambdaCodeChange,
        publishVersion: versionsReferencingFunction.length > 0,
        aliasesNames,
    });
}
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
/**
 * Returns  is a given Alias change is only in the 'FunctionVersion' property,
 * and `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` is the change is for any other property.
 */
function checkAliasHasVersionOnlyChange(change) {
    for (const updatedPropName in change.propertyUpdates) {
        if (updatedPropName !== 'FunctionVersion') {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    return common_1.ChangeHotswapImpact.IRRELEVANT;
}
/**
 * Returns `ChangeHotswapImpact.IRRELEVANT` if the change is not for a AWS::Lambda::Function,
 * but doesn't prevent short-circuiting
 * (like a change to CDKMetadata resource),
 * `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change is to a AWS::Lambda::Function,
 * but not only to its Code property,
 * or a LambdaFunctionCode if the change is to a AWS::Lambda::Function,
 * and only affects its Code property.
 */
async function isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate) {
    const newResourceType = change.newValue.Type;
    if (newResourceType !== 'AWS::Lambda::Function') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    /*
     * At first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    const propertyUpdates = change.propertyUpdates;
    let code = undefined;
    let tags = undefined;
    let description = undefined;
    let environment = undefined;
    for (const updatedPropName in propertyUpdates) {
        const updatedProp = propertyUpdates[updatedPropName];
        switch (updatedPropName) {
            case 'Code':
                let foundCodeDifference = false;
                let s3Bucket, s3Key, imageUri, functionCodeZip;
                for (const newPropName in updatedProp.newValue) {
                    switch (newPropName) {
                        case 'S3Bucket':
                            foundCodeDifference = true;
                            s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'S3Key':
                            foundCodeDifference = true;
                            s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ImageUri':
                            foundCodeDifference = true;
                            imageUri = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ZipFile':
                            foundCodeDifference = true;
                            // We must create a zip package containing a file with the inline code
                            const functionCode = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            const functionRuntime = await evaluateCfnTemplate.evaluateCfnExpression(change.newValue.Properties?.Runtime);
                            if (!functionRuntime) {
                                return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
                            }
                            // file extension must be chosen depending on the runtime
                            const codeFileExt = determineCodeFileExtFromRuntime(functionRuntime);
                            functionCodeZip = await zipString(`index.${codeFileExt}`, functionCode);
                            break;
                        default:
                            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
                    }
                }
                if (foundCodeDifference) {
                    code = {
                        s3Bucket,
                        s3Key,
                        imageUri,
                        functionCodeZip,
                    };
                }
                break;
            case 'Tags':
                /*
                 * Tag updates are a bit odd; they manifest as two lists, are flagged only as
                 * `isDifferent`, and we have to reconcile them.
                 */
                const tagUpdates = {};
                if (updatedProp?.isDifferent) {
                    const tasks = updatedProp.newValue.map(async (tag) => {
                        tagUpdates[tag.Key] = await evaluateCfnTemplate.evaluateCfnExpression(tag.Value);
                    });
                    await Promise.all(tasks);
                    updatedProp.oldValue.forEach((tag) => {
                        if (tagUpdates[tag.Key] === undefined) {
                            tagUpdates[tag.Key] = TagDeletion.DELETE;
                        }
                    });
                    tags = { tagUpdates };
                }
                break;
            case 'Description':
                description = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
                break;
            case 'Environment':
                environment = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
                break;
            default:
                return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    const configurations = description || environment ? { description, environment } : undefined;
    return code || tags || configurations ? { code, tags, configurations } : common_1.ChangeHotswapImpact.IRRELEVANT;
}
var TagDeletion;
(function (TagDeletion) {
    TagDeletion[TagDeletion["DELETE"] = -1] = "DELETE";
})(TagDeletion || (TagDeletion = {}));
class LambdaFunctionHotswapOperation {
    constructor(lambdaFunctionResource) {
        this.lambdaFunctionResource = lambdaFunctionResource;
        this.service = 'lambda-function';
        this.resourceNames = [
            `Lambda Function '${lambdaFunctionResource.physicalName}'`,
            // add Version here if we're publishing a new one
            ...(lambdaFunctionResource.publishVersion ? [`Lambda Version for Function '${lambdaFunctionResource.physicalName}'`] : []),
            // add any Aliases that we are hotswapping here
            ...lambdaFunctionResource.aliasesNames.map(alias => `Lambda Alias '${alias}' for Function '${lambdaFunctionResource.physicalName}'`),
        ];
    }
    async apply(sdk) {
        const lambda = sdk.lambda();
        const resource = this.lambdaFunctionResource.resource;
        const operations = [];
        if (resource.code !== undefined || resource.configurations !== undefined) {
            if (resource.code !== undefined) {
                const updateFunctionCodeResponse = await lambda.updateFunctionCode({
                    FunctionName: this.lambdaFunctionResource.physicalName,
                    S3Bucket: resource.code.s3Bucket,
                    S3Key: resource.code.s3Key,
                    ImageUri: resource.code.imageUri,
                    ZipFile: resource.code.functionCodeZip,
                }).promise();
                await this.waitForLambdasPropertiesUpdateToFinish(updateFunctionCodeResponse, lambda);
            }
            if (resource.configurations !== undefined) {
                const updateRequest = {
                    FunctionName: this.lambdaFunctionResource.physicalName,
                };
                if (resource.configurations.description !== undefined) {
                    updateRequest.Description = resource.configurations.description;
                }
                if (resource.configurations.environment !== undefined) {
                    updateRequest.Environment = resource.configurations.environment;
                }
                const updateFunctionCodeResponse = await lambda.updateFunctionConfiguration(updateRequest).promise();
                await this.waitForLambdasPropertiesUpdateToFinish(updateFunctionCodeResponse, lambda);
            }
            // only if the code changed is there any point in publishing a new Version
            if (this.lambdaFunctionResource.publishVersion) {
                const publishVersionPromise = lambda.publishVersion({
                    FunctionName: this.lambdaFunctionResource.physicalName,
                }).promise();
                if (this.lambdaFunctionResource.aliasesNames.length > 0) {
                    // we need to wait for the Version to finish publishing
                    const versionUpdate = await publishVersionPromise;
                    for (const alias of this.lambdaFunctionResource.aliasesNames) {
                        operations.push(lambda.updateAlias({
                            FunctionName: this.lambdaFunctionResource.physicalName,
                            Name: alias,
                            FunctionVersion: versionUpdate.Version,
                        }).promise());
                    }
                }
                else {
                    operations.push(publishVersionPromise);
                }
            }
        }
        if (resource.tags !== undefined) {
            const tagsToDelete = Object.entries(resource.tags.tagUpdates)
                .filter(([_key, val]) => val === TagDeletion.DELETE)
                .map(([key, _val]) => key);
            const tagsToSet = {};
            Object.entries(resource.tags.tagUpdates)
                .filter(([_key, val]) => val !== TagDeletion.DELETE)
                .forEach(([tagName, tagValue]) => {
                tagsToSet[tagName] = tagValue;
            });
            if (tagsToDelete.length > 0) {
                operations.push(lambda.untagResource({
                    Resource: this.lambdaFunctionResource.functionArn,
                    TagKeys: tagsToDelete,
                }).promise());
            }
            if (Object.keys(tagsToSet).length > 0) {
                operations.push(lambda.tagResource({
                    Resource: this.lambdaFunctionResource.functionArn,
                    Tags: tagsToSet,
                }).promise());
            }
        }
        // run all of our updates in parallel
        return Promise.all(operations);
    }
    /**
     * After a Lambda Function is updated, it cannot be updated again until the
     * `State=Active` and the `LastUpdateStatus=Successful`.
     *
     * Depending on the configuration of the Lambda Function this could happen relatively quickly
     * or very slowly. For example, Zip based functions _not_ in a VPC can take ~1 second whereas VPC
     * or Container functions can take ~25 seconds (and 'idle' VPC functions can take minutes).
     */
    async waitForLambdasPropertiesUpdateToFinish(currentFunctionConfiguration, lambda) {
        const functionIsInVpcOrUsesDockerForCode = currentFunctionConfiguration.VpcConfig?.VpcId ||
            currentFunctionConfiguration.PackageType === 'Image';
        // if the function is deployed in a VPC or if it is a container image function
        // then the update will take much longer and we can wait longer between checks
        // otherwise, the update will be quick, so a 1-second delay is fine
        const delaySeconds = functionIsInVpcOrUsesDockerForCode ? 5 : 1;
        // configure a custom waiter to wait for the function update to complete
        lambda.api.waiters.updateFunctionPropertiesToFinish = {
            name: 'UpdateFunctionPropertiesToFinish',
            operation: 'getFunction',
            // equates to 1 minute for zip function not in a VPC and
            // 5 minutes for container functions or function in a VPC
            maxAttempts: 60,
            delay: delaySeconds,
            acceptors: [
                {
                    matcher: 'path',
                    argument: "Configuration.LastUpdateStatus == 'Successful' && Configuration.State == 'Active'",
                    expected: true,
                    state: 'success',
                },
                {
                    matcher: 'path',
                    argument: 'Configuration.LastUpdateStatus',
                    expected: 'Failed',
                    state: 'failure',
                },
            ],
        };
        const updateFunctionPropertiesWaiter = new AWS.ResourceWaiter(lambda, 'updateFunctionPropertiesToFinish');
        await updateFunctionPropertiesWaiter.wait({
            FunctionName: this.lambdaFunctionResource.physicalName,
        }).promise();
    }
}
/**
 * Compress a string as a file, returning a promise for the zip buffer
 * https://github.com/archiverjs/node-archiver/issues/342
 */
function zipString(fileName, rawString) {
    return new Promise((resolve, reject) => {
        const buffers = [];
        const converter = new stream_1.Writable();
        converter._write = (chunk, _, callback) => {
            buffers.push(chunk);
            process.nextTick(callback);
        };
        converter.on('finish', () => {
            resolve(Buffer.concat(buffers));
        });
        const archive = archiver('zip');
        archive.on('error', (err) => {
            reject(err);
        });
        archive.pipe(converter);
        archive.append(rawString, {
            name: fileName,
            date: new Date('1980-01-01T00:00:00.000Z'),
        });
        void archive.finalize();
    });
}
/**
 * Get file extension from Lambda runtime string.
 * We use this extension to create a deployment package from Lambda inline code.
 */
function determineCodeFileExtFromRuntime(runtime) {
    if (runtime.startsWith('node')) {
        return 'js';
    }
    if (runtime.startsWith('python')) {
        return 'py';
    }
    // Currently inline code only supports Node.js and Python, ignoring other runtimes.
    // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#aws-properties-lambda-function-code-properties
    throw new evaluate_cloudformation_template_1.CfnEvaluationException(`runtime ${runtime} is unsupported, only node.js and python runtimes are currently supported.`);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFFckMsMEZBQTZHO0FBQzdHLHFDQUFtSDtBQUVuSCx5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUVyQzs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxrQ0FBa0MsQ0FDdEQsU0FBaUIsRUFBRSxNQUFtQyxFQUFFLG1CQUFtRDtJQUUzRyx5Q0FBeUM7SUFDekMsc0RBQXNEO0lBQ3RELDZHQUE2RztJQUM3RywwRUFBMEU7SUFDMUUsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxzQkFBc0IsRUFBRTtRQUNuRCxPQUFPLDRCQUFtQixDQUFDLFVBQVUsQ0FBQztLQUN2QztJQUVELGtDQUFrQztJQUNsQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLG9CQUFvQixFQUFFO1FBQ2pELE9BQU8sOEJBQThCLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDL0M7SUFFRCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sOEJBQThCLENBQUMsTUFBTSxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDM0YsSUFBSSxPQUFPLGdCQUFnQixLQUFLLFFBQVEsRUFBRTtRQUN4QyxPQUFPLGdCQUFnQixDQUFDO0tBQ3pCO0lBRUQsTUFBTSxZQUFZLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyw2QkFBNkIsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDbEksSUFBSSxDQUFDLFlBQVksRUFBRTtRQUNqQixPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO0tBQ3JEO0lBRUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQztRQUNsRSxTQUFTLEVBQUUseUVBQXlFLEdBQUcsWUFBWTtLQUNwRyxDQUFDLENBQUM7SUFFSCx3REFBd0Q7SUFDeEQsTUFBTSwyQkFBMkIsR0FBRyxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUM7U0FDaEYsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ2xELDREQUE0RDtJQUM1RCxNQUFNLDBCQUEwQixHQUFHLGNBQU8sQ0FBQywyQkFBMkIsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUMxRSxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUNyRCxNQUFNLFlBQVksR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQ3hFLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRWxFLE9BQU8sSUFBSSw4QkFBOEIsQ0FBQztRQUN4QyxZQUFZLEVBQUUsWUFBWTtRQUMxQixXQUFXLEVBQUUsV0FBVztRQUN4QixRQUFRLEVBQUUsZ0JBQWdCO1FBQzFCLGNBQWMsRUFBRSwyQkFBMkIsQ0FBQyxNQUFNLEdBQUcsQ0FBQztRQUN0RCxZQUFZO0tBQ2IsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQTlDRCxnRkE4Q0M7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLDhCQUE4QixDQUFDLE1BQW1DO0lBQ3pFLEtBQUssTUFBTSxlQUFlLElBQUksTUFBTSxDQUFDLGVBQWUsRUFBRTtRQUNwRCxJQUFJLGVBQWUsS0FBSyxpQkFBaUIsRUFBRTtZQUN6QyxPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO1NBQ3JEO0tBQ0Y7SUFDRCxPQUFPLDRCQUFtQixDQUFDLFVBQVUsQ0FBQztBQUN4QyxDQUFDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxLQUFLLFVBQVUsOEJBQThCLENBQzNDLE1BQW1DLEVBQUUsbUJBQW1EO0lBRXhGLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0lBQzdDLElBQUksZUFBZSxLQUFLLHVCQUF1QixFQUFFO1FBQy9DLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7S0FDckQ7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLGVBQWUsQ0FBQztJQUMvQyxJQUFJLElBQUksR0FBbUMsU0FBUyxDQUFDO0lBQ3JELElBQUksSUFBSSxHQUFtQyxTQUFTLENBQUM7SUFDckQsSUFBSSxXQUFXLEdBQXVCLFNBQVMsQ0FBQztJQUNoRCxJQUFJLFdBQVcsR0FBMEMsU0FBUyxDQUFDO0lBRW5FLEtBQUssTUFBTSxlQUFlLElBQUksZUFBZSxFQUFFO1FBQzdDLE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUVyRCxRQUFRLGVBQWUsRUFBRTtZQUN2QixLQUFLLE1BQU07Z0JBQ1QsSUFBSSxtQkFBbUIsR0FBRyxLQUFLLENBQUM7Z0JBQ2hDLElBQUksUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsZUFBZSxDQUFDO2dCQUUvQyxLQUFLLE1BQU0sV0FBVyxJQUFJLFdBQVcsQ0FBQyxRQUFRLEVBQUU7b0JBQzlDLFFBQVEsV0FBVyxFQUFFO3dCQUNuQixLQUFLLFVBQVU7NEJBQ2IsbUJBQW1CLEdBQUcsSUFBSSxDQUFDOzRCQUMzQixRQUFRLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7NEJBQzlGLE1BQU07d0JBQ1IsS0FBSyxPQUFPOzRCQUNWLG1CQUFtQixHQUFHLElBQUksQ0FBQzs0QkFDM0IsS0FBSyxHQUFHLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDOzRCQUMzRixNQUFNO3dCQUNSLEtBQUssVUFBVTs0QkFDYixtQkFBbUIsR0FBRyxJQUFJLENBQUM7NEJBQzNCLFFBQVEsR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQzs0QkFDOUYsTUFBTTt3QkFDUixLQUFLLFNBQVM7NEJBQ1osbUJBQW1CLEdBQUcsSUFBSSxDQUFDOzRCQUMzQixzRUFBc0U7NEJBQ3RFLE1BQU0sWUFBWSxHQUFHLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDOzRCQUN4RyxNQUFNLGVBQWUsR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDOzRCQUM3RyxJQUFJLENBQUMsZUFBZSxFQUFFO2dDQUNwQixPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDOzZCQUNyRDs0QkFDRCx5REFBeUQ7NEJBQ3pELE1BQU0sV0FBVyxHQUFHLCtCQUErQixDQUFDLGVBQWUsQ0FBQyxDQUFDOzRCQUNyRSxlQUFlLEdBQUcsTUFBTSxTQUFTLENBQUMsU0FBUyxXQUFXLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQzs0QkFDeEUsTUFBTTt3QkFDUjs0QkFDRSxPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO3FCQUN2RDtpQkFDRjtnQkFDRCxJQUFJLG1CQUFtQixFQUFFO29CQUN2QixJQUFJLEdBQUc7d0JBQ0wsUUFBUTt3QkFDUixLQUFLO3dCQUNMLFFBQVE7d0JBQ1IsZUFBZTtxQkFDaEIsQ0FBQztpQkFDSDtnQkFDRCxNQUFNO1lBQ1IsS0FBSyxNQUFNO2dCQUNUOzs7bUJBR0c7Z0JBQ0gsTUFBTSxVQUFVLEdBQTRDLEVBQUUsQ0FBQztnQkFDL0QsSUFBSSxXQUFXLEVBQUUsV0FBVyxFQUFFO29CQUM1QixNQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBb0IsRUFBRSxFQUFFO3dCQUNwRSxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNuRixDQUFDLENBQUMsQ0FBQztvQkFDSCxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBRXpCLFdBQVcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBb0IsRUFBRSxFQUFFO3dCQUNwRCxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxFQUFFOzRCQUNyQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7eUJBQzFDO29CQUNILENBQUMsQ0FBQyxDQUFDO29CQUVILElBQUksR0FBRyxFQUFFLFVBQVUsRUFBRSxDQUFDO2lCQUN2QjtnQkFDRCxNQUFNO1lBQ1IsS0FBSyxhQUFhO2dCQUNoQixXQUFXLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3BGLE1BQU07WUFDUixLQUFLLGFBQWE7Z0JBQ2hCLFdBQVcsR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDcEYsTUFBTTtZQUNSO2dCQUNFLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDdkQ7S0FDRjtJQUVELE1BQU0sY0FBYyxHQUFHLFdBQVcsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDN0YsT0FBTyxJQUFJLElBQUksSUFBSSxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyw0QkFBbUIsQ0FBQyxVQUFVLENBQUM7QUFDMUcsQ0FBQztBQWNELElBQUssV0FFSjtBQUZELFdBQUssV0FBVztJQUNkLGtEQUFXLENBQUE7QUFDYixDQUFDLEVBRkksV0FBVyxLQUFYLFdBQVcsUUFFZjtBQXlCRCxNQUFNLDhCQUE4QjtJQUlsQyxZQUE2QixzQkFBOEM7UUFBOUMsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUF3QjtRQUgzRCxZQUFPLEdBQUcsaUJBQWlCLENBQUM7UUFJMUMsSUFBSSxDQUFDLGFBQWEsR0FBRztZQUNuQixvQkFBb0Isc0JBQXNCLENBQUMsWUFBWSxHQUFHO1lBQzFELGlEQUFpRDtZQUNqRCxHQUFHLENBQUMsc0JBQXNCLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLGdDQUFnQyxzQkFBc0IsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDMUgsK0NBQStDO1lBQy9DLEdBQUcsc0JBQXNCLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLGlCQUFpQixLQUFLLG1CQUFtQixzQkFBc0IsQ0FBQyxZQUFZLEdBQUcsQ0FBQztTQUNySSxDQUFDO0lBQ0osQ0FBQztJQUVNLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBUztRQUMxQixNQUFNLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDNUIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQztRQUN0RCxNQUFNLFVBQVUsR0FBbUIsRUFBRSxDQUFDO1FBRXRDLElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxTQUFTLElBQUksUUFBUSxDQUFDLGNBQWMsS0FBSyxTQUFTLEVBQUU7WUFDeEUsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtnQkFDL0IsTUFBTSwwQkFBMEIsR0FBRyxNQUFNLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQztvQkFDakUsWUFBWSxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZO29CQUN0RCxRQUFRLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRO29CQUNoQyxLQUFLLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLO29CQUMxQixRQUFRLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRO29CQUNoQyxPQUFPLEVBQUUsUUFBUSxDQUFDLElBQUksQ0FBQyxlQUFlO2lCQUN2QyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBRWIsTUFBTSxJQUFJLENBQUMsc0NBQXNDLENBQUMsMEJBQTBCLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDdkY7WUFFRCxJQUFJLFFBQVEsQ0FBQyxjQUFjLEtBQUssU0FBUyxFQUFFO2dCQUN6QyxNQUFNLGFBQWEsR0FBa0Q7b0JBQ25FLFlBQVksRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsWUFBWTtpQkFDdkQsQ0FBQztnQkFDRixJQUFJLFFBQVEsQ0FBQyxjQUFjLENBQUMsV0FBVyxLQUFLLFNBQVMsRUFBRTtvQkFDckQsYUFBYSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQztpQkFDakU7Z0JBQ0QsSUFBSSxRQUFRLENBQUMsY0FBYyxDQUFDLFdBQVcsS0FBSyxTQUFTLEVBQUU7b0JBQ3JELGFBQWEsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUM7aUJBQ2pFO2dCQUNELE1BQU0sMEJBQTBCLEdBQUcsTUFBTSxNQUFNLENBQUMsMkJBQTJCLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3JHLE1BQU0sSUFBSSxDQUFDLHNDQUFzQyxDQUFDLDBCQUEwQixFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQ3ZGO1lBRUQsMEVBQTBFO1lBQzFFLElBQUksSUFBSSxDQUFDLHNCQUFzQixDQUFDLGNBQWMsRUFBRTtnQkFDOUMsTUFBTSxxQkFBcUIsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDO29CQUNsRCxZQUFZLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFlBQVk7aUJBQ3ZELENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFFYixJQUFJLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDdkQsdURBQXVEO29CQUN2RCxNQUFNLGFBQWEsR0FBRyxNQUFNLHFCQUFxQixDQUFDO29CQUVsRCxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZLEVBQUU7d0JBQzVELFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQzs0QkFDakMsWUFBWSxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxZQUFZOzRCQUN0RCxJQUFJLEVBQUUsS0FBSzs0QkFDWCxlQUFlLEVBQUUsYUFBYSxDQUFDLE9BQU87eUJBQ3ZDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO3FCQUNmO2lCQUNGO3FCQUFNO29CQUNMLFVBQVUsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQztpQkFDeEM7YUFDRjtTQUNGO1FBRUQsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUMvQixNQUFNLFlBQVksR0FBYSxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO2lCQUNwRSxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxLQUFLLFdBQVcsQ0FBQyxNQUFNLENBQUM7aUJBQ25ELEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUU3QixNQUFNLFNBQVMsR0FBOEIsRUFBRSxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUssQ0FBQyxVQUFVLENBQUM7aUJBQ3RDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEtBQUssV0FBVyxDQUFDLE1BQU0sQ0FBQztpQkFDbkQsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLEVBQUUsRUFBRTtnQkFDL0IsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLFFBQWtCLENBQUM7WUFDMUMsQ0FBQyxDQUFDLENBQUM7WUFFTCxJQUFJLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUMzQixVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7b0JBQ25DLFFBQVEsRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsV0FBVztvQkFDakQsT0FBTyxFQUFFLFlBQVk7aUJBQ3RCLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2FBQ2Y7WUFFRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDckMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDO29CQUNqQyxRQUFRLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFdBQVc7b0JBQ2pELElBQUksRUFBRSxTQUFTO2lCQUNoQixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQzthQUNmO1NBQ0Y7UUFFRCxxQ0FBcUM7UUFDckMsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ssS0FBSyxDQUFDLHNDQUFzQyxDQUNsRCw0QkFBOEQsRUFBRSxNQUFrQjtRQUVsRixNQUFNLGtDQUFrQyxHQUFHLDRCQUE0QixDQUFDLFNBQVMsRUFBRSxLQUFLO1lBQ3BGLDRCQUE0QixDQUFDLFdBQVcsS0FBSyxPQUFPLENBQUM7UUFFekQsOEVBQThFO1FBQzlFLDhFQUE4RTtRQUM5RSxtRUFBbUU7UUFDbkUsTUFBTSxZQUFZLEdBQUcsa0NBQWtDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWhFLHdFQUF3RTtRQUN2RSxNQUFjLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxnQ0FBZ0MsR0FBRztZQUM3RCxJQUFJLEVBQUUsa0NBQWtDO1lBQ3hDLFNBQVMsRUFBRSxhQUFhO1lBQ3hCLHdEQUF3RDtZQUN4RCx5REFBeUQ7WUFDekQsV0FBVyxFQUFFLEVBQUU7WUFDZixLQUFLLEVBQUUsWUFBWTtZQUNuQixTQUFTLEVBQUU7Z0JBQ1Q7b0JBQ0UsT0FBTyxFQUFFLE1BQU07b0JBQ2YsUUFBUSxFQUFFLG1GQUFtRjtvQkFDN0YsUUFBUSxFQUFFLElBQUk7b0JBQ2QsS0FBSyxFQUFFLFNBQVM7aUJBQ2pCO2dCQUNEO29CQUNFLE9BQU8sRUFBRSxNQUFNO29CQUNmLFFBQVEsRUFBRSxnQ0FBZ0M7b0JBQzFDLFFBQVEsRUFBRSxRQUFRO29CQUNsQixLQUFLLEVBQUUsU0FBUztpQkFDakI7YUFDRjtTQUNGLENBQUM7UUFFRixNQUFNLDhCQUE4QixHQUFHLElBQUssR0FBVyxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsa0NBQWtDLENBQUMsQ0FBQztRQUNuSCxNQUFNLDhCQUE4QixDQUFDLElBQUksQ0FBQztZQUN4QyxZQUFZLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFlBQVk7U0FDdkQsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2YsQ0FBQztDQUNGO0FBRUQ7OztHQUdHO0FBQ0gsU0FBUyxTQUFTLENBQUMsUUFBZ0IsRUFBRSxTQUFpQjtJQUNwRCxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1FBQ3JDLE1BQU0sT0FBTyxHQUFhLEVBQUUsQ0FBQztRQUU3QixNQUFNLFNBQVMsR0FBRyxJQUFJLGlCQUFRLEVBQUUsQ0FBQztRQUVqQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsS0FBYSxFQUFFLENBQVMsRUFBRSxRQUFvQixFQUFFLEVBQUU7WUFDcEUsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNwQixPQUFPLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdCLENBQUMsQ0FBQztRQUVGLFNBQVMsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRTtZQUMxQixPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWhDLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBUSxFQUFFLEVBQUU7WUFDL0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2QsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXhCLE9BQU8sQ0FBQyxNQUFNLENBQUMsU0FBUyxFQUFFO1lBQ3hCLElBQUksRUFBRSxRQUFRO1lBQ2QsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLDBCQUEwQixDQUFDO1NBQzNDLENBQUMsQ0FBQztRQUVILEtBQUssT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzFCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7R0FHRztBQUNILFNBQVMsK0JBQStCLENBQUMsT0FBZTtJQUN0RCxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDOUIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUNELElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUNoQyxPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsbUZBQW1GO0lBQ25GLHlKQUF5SjtJQUN6SixNQUFNLElBQUkseURBQXNCLENBQUMsV0FBVyxPQUFPLDRFQUE0RSxDQUFDLENBQUM7QUFDbkksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdyaXRhYmxlIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IGZsYXRNYXAgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uLCBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBDaGFuZ2VIb3Rzd2FwSW1wYWN0LCBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBIb3Rzd2FwT3BlcmF0aW9uLCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUgfSBmcm9tICcuL2NvbW1vbic7XG5cbi8vIG5hbWVzcGFjZSBvYmplY3QgaW1wb3J0cyB3b24ndCB3b3JrIGluIHRoZSBidW5kbGUgZm9yIGZ1bmN0aW9uIGV4cG9ydHNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG5jb25zdCBhcmNoaXZlciA9IHJlcXVpcmUoJ2FyY2hpdmVyJyk7XG5cbi8qKlxuICogUmV0dXJucyBgQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlRgIGlmIHRoZSBjaGFuZ2UgY2Fubm90IGJlIHNob3J0LWNpcmN1aXRlZCxcbiAqIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlRgIGlmIHRoZSBjaGFuZ2UgaXMgaXJyZWxldmFudCBmcm9tIGEgc2hvcnQtY2lyY3VpdCBwZXJzcGVjdGl2ZVxuICogKGxpa2UgYSBjaGFuZ2UgdG8gQ0RLTWV0YWRhdGEpLFxuICogb3IgYSBMYW1iZGFGdW5jdGlvblJlc291cmNlIGlmIHRoZSBjaGFuZ2UgY2FuIGJlIHNob3J0LWNpcmN1aXRlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiB7XG4gIC8vIGlmIHRoZSBjaGFuZ2UgaXMgZm9yIGEgTGFtYmRhIFZlcnNpb24sXG4gIC8vIGlnbm9yZSBpdCBieSByZXR1cm5pbmcgYW4gZW1wdHkgaG90c3dhcCBvcGVyYXRpb24gLVxuICAvLyB3ZSB3aWxsIHB1Ymxpc2ggYSBuZXcgdmVyc2lvbiB3aGVuIHdlIGdldCB0byBob3Rzd2FwcGluZyB0aGUgYWN0dWFsIEZ1bmN0aW9uIHRoaXMgVmVyc2lvbiBwb2ludHMgdG8sIGJlbG93XG4gIC8vIChWZXJzaW9ucyBjYW4ndCBiZSBjaGFuZ2VkIGluIENsb3VkRm9ybWF0aW9uIGFueXdheSwgdGhleSdyZSBpbW11dGFibGUpXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSA9PT0gJ0FXUzo6TGFtYmRhOjpWZXJzaW9uJykge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlQ7XG4gIH1cblxuICAvLyB3ZSBoYW5kbGUgQWxpYXNlcyBzcGVjaWFsbHkgdG9vXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSA9PT0gJ0FXUzo6TGFtYmRhOjpBbGlhcycpIHtcbiAgICByZXR1cm4gY2hlY2tBbGlhc0hhc1ZlcnNpb25Pbmx5Q2hhbmdlKGNoYW5nZSk7XG4gIH1cblxuICBjb25zdCBsYW1iZGFDb2RlQ2hhbmdlID0gYXdhaXQgaXNMYW1iZGFGdW5jdGlvbkNvZGVPbmx5Q2hhbmdlKGNoYW5nZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSk7XG4gIGlmICh0eXBlb2YgbGFtYmRhQ29kZUNoYW5nZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbGFtYmRhQ29kZUNoYW5nZTtcbiAgfVxuXG4gIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUobG9naWNhbElkLCBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uRnVuY3Rpb25OYW1lKTtcbiAgaWYgKCFmdW5jdGlvbk5hbWUpIHtcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gIH1cblxuICBjb25zdCBmdW5jdGlvbkFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHtcbiAgICAnRm46OlN1Yic6ICdhcm46JHtBV1M6OlBhcnRpdGlvbn06bGFtYmRhOiR7QVdTOjpSZWdpb259OiR7QVdTOjpBY2NvdW50SWR9OmZ1bmN0aW9uOicgKyBmdW5jdGlvbk5hbWUsXG4gIH0pO1xuXG4gIC8vIGZpbmQgYWxsIExhbWJkYSBWZXJzaW9ucyB0aGF0IHJlZmVyZW5jZSB0aGlzIEZ1bmN0aW9uXG4gIGNvbnN0IHZlcnNpb25zUmVmZXJlbmNpbmdGdW5jdGlvbiA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyhsb2dpY2FsSWQpXG4gICAgLmZpbHRlcihyID0+IHIuVHlwZSA9PT0gJ0FXUzo6TGFtYmRhOjpWZXJzaW9uJyk7XG4gIC8vIGZpbmQgYWxsIExhbWJkYSBBbGlhc2VzIHRoYXQgcmVmZXJlbmNlIHRoZSBhYm92ZSBWZXJzaW9uc1xuICBjb25zdCBhbGlhc2VzUmVmZXJlbmNpbmdWZXJzaW9ucyA9IGZsYXRNYXAodmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uLCB2ID0+XG4gICAgZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUmVmZXJlbmNlc1RvKHYuTG9naWNhbElkKSk7XG4gIGNvbnN0IGFsaWFzZXNOYW1lcyA9IGF3YWl0IFByb21pc2UuYWxsKGFsaWFzZXNSZWZlcmVuY2luZ1ZlcnNpb25zLm1hcChhID0+XG4gICAgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oYS5Qcm9wZXJ0aWVzPy5OYW1lKSkpO1xuXG4gIHJldHVybiBuZXcgTGFtYmRhRnVuY3Rpb25Ib3Rzd2FwT3BlcmF0aW9uKHtcbiAgICBwaHlzaWNhbE5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICBmdW5jdGlvbkFybjogZnVuY3Rpb25Bcm4sXG4gICAgcmVzb3VyY2U6IGxhbWJkYUNvZGVDaGFuZ2UsXG4gICAgcHVibGlzaFZlcnNpb246IHZlcnNpb25zUmVmZXJlbmNpbmdGdW5jdGlvbi5sZW5ndGggPiAwLFxuICAgIGFsaWFzZXNOYW1lcyxcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyAgaXMgYSBnaXZlbiBBbGlhcyBjaGFuZ2UgaXMgb25seSBpbiB0aGUgJ0Z1bmN0aW9uVmVyc2lvbicgcHJvcGVydHksXG4gKiBhbmQgYENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UYCBpcyB0aGUgY2hhbmdlIGlzIGZvciBhbnkgb3RoZXIgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQWxpYXNIYXNWZXJzaW9uT25seUNoYW5nZShjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSk6IENoYW5nZUhvdHN3YXBSZXN1bHQge1xuICBmb3IgKGNvbnN0IHVwZGF0ZWRQcm9wTmFtZSBpbiBjaGFuZ2UucHJvcGVydHlVcGRhdGVzKSB7XG4gICAgaWYgKHVwZGF0ZWRQcm9wTmFtZSAhPT0gJ0Z1bmN0aW9uVmVyc2lvbicpIHtcbiAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlRgIGlmIHRoZSBjaGFuZ2UgaXMgbm90IGZvciBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGJ1dCBkb2Vzbid0IHByZXZlbnQgc2hvcnQtY2lyY3VpdGluZ1xuICogKGxpa2UgYSBjaGFuZ2UgdG8gQ0RLTWV0YWRhdGEgcmVzb3VyY2UpLFxuICogYENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UYCBpZiB0aGUgY2hhbmdlIGlzIHRvIGEgQVdTOjpMYW1iZGE6OkZ1bmN0aW9uLFxuICogYnV0IG5vdCBvbmx5IHRvIGl0cyBDb2RlIHByb3BlcnR5LFxuICogb3IgYSBMYW1iZGFGdW5jdGlvbkNvZGUgaWYgdGhlIGNoYW5nZSBpcyB0byBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGFuZCBvbmx5IGFmZmVjdHMgaXRzIENvZGUgcHJvcGVydHkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzTGFtYmRhRnVuY3Rpb25Db2RlT25seUNoYW5nZShcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8TGFtYmRhRnVuY3Rpb25DaGFuZ2UgfCBDaGFuZ2VIb3Rzd2FwSW1wYWN0PiB7XG4gIGNvbnN0IG5ld1Jlc291cmNlVHlwZSA9IGNoYW5nZS5uZXdWYWx1ZS5UeXBlO1xuICBpZiAobmV3UmVzb3VyY2VUeXBlICE9PSAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJykge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIC8qXG4gICAqIEF0IGZpcnN0IGdsYW5jZSwgd2Ugd291bGQgd2FudCB0byBpbml0aWFsaXplIHRoZXNlIHVzaW5nIHRoZSBcInByZXZpb3VzXCIgdmFsdWVzIChjaGFuZ2Uub2xkVmFsdWUpLFxuICAgKiBpbiBjYXNlIG9ubHkgb25lIG9mIHRoZW0gY2hhbmdlZCwgbGlrZSB0aGUga2V5LCBhbmQgdGhlIEJ1Y2tldCBzdGF5ZWQgdGhlIHNhbWUuXG4gICAqIEhvd2V2ZXIsIHRoYXQgYWN0dWFsbHkgZmFpbHMgZm9yIG9sZC1zdHlsZSBzeW50aGVzaXMsIHdoaWNoIHVzZXMgQ0ZOIFBhcmFtZXRlcnMhXG4gICAqIEJlY2F1c2UgdGhlIG5hbWVzIG9mIHRoZSBQYXJhbWV0ZXJzIGRlcGVuZCBvbiB0aGUgaGFzaCBvZiB0aGUgQXNzZXQsXG4gICAqIHRoZSBQYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBcIm9sZFwiIHZhbHVlcyBubyBsb25nZXIgZXhpc3QgaW4gYGFzc2V0UGFyYW1zYCBhdCB0aGlzIHBvaW50LFxuICAgKiB3aGljaCBtZWFucyB3ZSBkb24ndCBoYXZlIHRoZSBjb3JyZWN0IHZhbHVlcyBhdmFpbGFibGUgdG8gZXZhbHVhdGUgdGhlIENGTiBleHByZXNzaW9uIHdpdGguXG4gICAqIEZvcnR1bmF0ZWx5LCB0aGUgZGlmZiB3aWxsIGFsd2F5cyBpbmNsdWRlIGJvdGggdGhlIHMzQnVja2V0IGFuZCBzM0tleSBwYXJ0cyBvZiB0aGUgTGFtYmRhJ3MgQ29kZSBwcm9wZXJ0eSxcbiAgICogZXZlbiBpZiBvbmx5IG9uZSBvZiB0aGVtIHdhcyBhY3R1YWxseSBjaGFuZ2VkLFxuICAgKiB3aGljaCBtZWFucyB3ZSBkb24ndCBuZWVkIHRoZSBcIm9sZFwiIHZhbHVlcyBhdCBhbGwsIGFuZCB3ZSBjYW4gc2FmZWx5IGluaXRpYWxpemUgdGhlc2Ugd2l0aCBqdXN0IGAnJ2AuXG4gICAqL1xuICBjb25zdCBwcm9wZXJ0eVVwZGF0ZXMgPSBjaGFuZ2UucHJvcGVydHlVcGRhdGVzO1xuICBsZXQgY29kZTogTGFtYmRhRnVuY3Rpb25Db2RlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgdGFnczogTGFtYmRhRnVuY3Rpb25UYWdzIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBsZXQgZGVzY3JpcHRpb246IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgbGV0IGVudmlyb25tZW50OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIGZvciAoY29uc3QgdXBkYXRlZFByb3BOYW1lIGluIHByb3BlcnR5VXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZWRQcm9wID0gcHJvcGVydHlVcGRhdGVzW3VwZGF0ZWRQcm9wTmFtZV07XG5cbiAgICBzd2l0Y2ggKHVwZGF0ZWRQcm9wTmFtZSkge1xuICAgICAgY2FzZSAnQ29kZSc6XG4gICAgICAgIGxldCBmb3VuZENvZGVEaWZmZXJlbmNlID0gZmFsc2U7XG4gICAgICAgIGxldCBzM0J1Y2tldCwgczNLZXksIGltYWdlVXJpLCBmdW5jdGlvbkNvZGVaaXA7XG5cbiAgICAgICAgZm9yIChjb25zdCBuZXdQcm9wTmFtZSBpbiB1cGRhdGVkUHJvcC5uZXdWYWx1ZSkge1xuICAgICAgICAgIHN3aXRjaCAobmV3UHJvcE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1MzQnVja2V0JzpcbiAgICAgICAgICAgICAgZm91bmRDb2RlRGlmZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgIHMzQnVja2V0ID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTM0tleSc6XG4gICAgICAgICAgICAgIGZvdW5kQ29kZURpZmZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICBzM0tleSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSW1hZ2VVcmknOlxuICAgICAgICAgICAgICBmb3VuZENvZGVEaWZmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaW1hZ2VVcmkgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1ppcEZpbGUnOlxuICAgICAgICAgICAgICBmb3VuZENvZGVEaWZmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gV2UgbXVzdCBjcmVhdGUgYSB6aXAgcGFja2FnZSBjb250YWluaW5nIGEgZmlsZSB3aXRoIHRoZSBpbmxpbmUgY29kZVxuICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbkNvZGUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvblJ1bnRpbWUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uUnVudGltZSk7XG4gICAgICAgICAgICAgIGlmICghZnVuY3Rpb25SdW50aW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGZpbGUgZXh0ZW5zaW9uIG11c3QgYmUgY2hvc2VuIGRlcGVuZGluZyBvbiB0aGUgcnVudGltZVxuICAgICAgICAgICAgICBjb25zdCBjb2RlRmlsZUV4dCA9IGRldGVybWluZUNvZGVGaWxlRXh0RnJvbVJ1bnRpbWUoZnVuY3Rpb25SdW50aW1lKTtcbiAgICAgICAgICAgICAgZnVuY3Rpb25Db2RlWmlwID0gYXdhaXQgemlwU3RyaW5nKGBpbmRleC4ke2NvZGVGaWxlRXh0fWAsIGZ1bmN0aW9uQ29kZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDb2RlRGlmZmVyZW5jZSkge1xuICAgICAgICAgIGNvZGUgPSB7XG4gICAgICAgICAgICBzM0J1Y2tldCxcbiAgICAgICAgICAgIHMzS2V5LFxuICAgICAgICAgICAgaW1hZ2VVcmksXG4gICAgICAgICAgICBmdW5jdGlvbkNvZGVaaXAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1RhZ3MnOlxuICAgICAgICAvKlxuICAgICAgICAgKiBUYWcgdXBkYXRlcyBhcmUgYSBiaXQgb2RkOyB0aGV5IG1hbmlmZXN0IGFzIHR3byBsaXN0cywgYXJlIGZsYWdnZWQgb25seSBhc1xuICAgICAgICAgKiBgaXNEaWZmZXJlbnRgLCBhbmQgd2UgaGF2ZSB0byByZWNvbmNpbGUgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHRhZ1VwZGF0ZXM6IHsgW3RhZzogc3RyaW5nXTogc3RyaW5nIHwgVGFnRGVsZXRpb24gfSA9IHt9O1xuICAgICAgICBpZiAodXBkYXRlZFByb3A/LmlzRGlmZmVyZW50KSB7XG4gICAgICAgICAgY29uc3QgdGFza3MgPSB1cGRhdGVkUHJvcC5uZXdWYWx1ZS5tYXAoYXN5bmMgKHRhZzogQ2ZuRGlmZlRhZ1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0YWdVcGRhdGVzW3RhZy5LZXldID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odGFnLlZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0YXNrcyk7XG5cbiAgICAgICAgICB1cGRhdGVkUHJvcC5vbGRWYWx1ZS5mb3JFYWNoKCh0YWc6IENmbkRpZmZUYWdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhZ1VwZGF0ZXNbdGFnLktleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0YWdVcGRhdGVzW3RhZy5LZXldID0gVGFnRGVsZXRpb24uREVMRVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGFncyA9IHsgdGFnVXBkYXRlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRGVzY3JpcHRpb24nOlxuICAgICAgICBkZXNjcmlwdGlvbiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFbnZpcm9ubWVudCc6XG4gICAgICAgIGVudmlyb25tZW50ID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjb25maWd1cmF0aW9ucyA9IGRlc2NyaXB0aW9uIHx8IGVudmlyb25tZW50ID8geyBkZXNjcmlwdGlvbiwgZW52aXJvbm1lbnQgfSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNvZGUgfHwgdGFncyB8fCBjb25maWd1cmF0aW9ucyA/IHsgY29kZSwgdGFncywgY29uZmlndXJhdGlvbnMgfSA6IENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVDtcbn1cblxuaW50ZXJmYWNlIENmbkRpZmZUYWdWYWx1ZSB7XG4gIHJlYWRvbmx5IEtleTogc3RyaW5nO1xuICByZWFkb25seSBWYWx1ZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25Db2RlIHtcbiAgcmVhZG9ubHkgczNCdWNrZXQ/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHMzS2V5Pzogc3RyaW5nO1xuICByZWFkb25seSBpbWFnZVVyaT86IHN0cmluZztcbiAgcmVhZG9ubHkgZnVuY3Rpb25Db2RlWmlwPzogQnVmZmVyO1xufVxuXG5lbnVtIFRhZ0RlbGV0aW9uIHtcbiAgREVMRVRFID0gLTEsXG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvblRhZ3Mge1xuICByZWFkb25seSB0YWdVcGRhdGVzOiB7IFt0YWcgOiBzdHJpbmddIDogc3RyaW5nIHwgVGFnRGVsZXRpb24gfTtcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uQ29uZmlndXJhdGlvbnMge1xuICByZWFkb25seSBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgcmVhZG9ubHkgZW52aXJvbm1lbnQ/OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25DaGFuZ2Uge1xuICByZWFkb25seSBjb2RlPzogTGFtYmRhRnVuY3Rpb25Db2RlO1xuICByZWFkb25seSB0YWdzPzogTGFtYmRhRnVuY3Rpb25UYWdzO1xuICByZWFkb25seSBjb25maWd1cmF0aW9ucz86IExhbWJkYUZ1bmN0aW9uQ29uZmlndXJhdGlvbnM7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvblJlc291cmNlIHtcbiAgcmVhZG9ubHkgcGh5c2ljYWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGZ1bmN0aW9uQXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlc291cmNlOiBMYW1iZGFGdW5jdGlvbkNoYW5nZTtcbiAgcmVhZG9ubHkgcHVibGlzaFZlcnNpb246IGJvb2xlYW47XG4gIHJlYWRvbmx5IGFsaWFzZXNOYW1lczogc3RyaW5nW107XG59XG5cbmNsYXNzIExhbWJkYUZ1bmN0aW9uSG90c3dhcE9wZXJhdGlvbiBpbXBsZW1lbnRzIEhvdHN3YXBPcGVyYXRpb24ge1xuICBwdWJsaWMgcmVhZG9ubHkgc2VydmljZSA9ICdsYW1iZGEtZnVuY3Rpb24nO1xuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VOYW1lczogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBsYW1iZGFGdW5jdGlvblJlc291cmNlOiBMYW1iZGFGdW5jdGlvblJlc291cmNlKSB7XG4gICAgdGhpcy5yZXNvdXJjZU5hbWVzID0gW1xuICAgICAgYExhbWJkYSBGdW5jdGlvbiAnJHtsYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZX0nYCxcbiAgICAgIC8vIGFkZCBWZXJzaW9uIGhlcmUgaWYgd2UncmUgcHVibGlzaGluZyBhIG5ldyBvbmVcbiAgICAgIC4uLihsYW1iZGFGdW5jdGlvblJlc291cmNlLnB1Ymxpc2hWZXJzaW9uID8gW2BMYW1iZGEgVmVyc2lvbiBmb3IgRnVuY3Rpb24gJyR7bGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWV9J2BdIDogW10pLFxuICAgICAgLy8gYWRkIGFueSBBbGlhc2VzIHRoYXQgd2UgYXJlIGhvdHN3YXBwaW5nIGhlcmVcbiAgICAgIC4uLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UuYWxpYXNlc05hbWVzLm1hcChhbGlhcyA9PiBgTGFtYmRhIEFsaWFzICcke2FsaWFzfScgZm9yIEZ1bmN0aW9uICcke2xhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lfSdgKSxcbiAgICBdO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFwcGx5KHNkazogSVNESyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgbGFtYmRhID0gc2RrLmxhbWJkYSgpO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnJlc291cmNlO1xuICAgIGNvbnN0IG9wZXJhdGlvbnM6IFByb21pc2U8YW55PltdID0gW107XG5cbiAgICBpZiAocmVzb3VyY2UuY29kZSAhPT0gdW5kZWZpbmVkIHx8IHJlc291cmNlLmNvbmZpZ3VyYXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChyZXNvdXJjZS5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlRnVuY3Rpb25Db2RlUmVzcG9uc2UgPSBhd2FpdCBsYW1iZGEudXBkYXRlRnVuY3Rpb25Db2RlKHtcbiAgICAgICAgICBGdW5jdGlvbk5hbWU6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWUsXG4gICAgICAgICAgUzNCdWNrZXQ6IHJlc291cmNlLmNvZGUuczNCdWNrZXQsXG4gICAgICAgICAgUzNLZXk6IHJlc291cmNlLmNvZGUuczNLZXksXG4gICAgICAgICAgSW1hZ2VVcmk6IHJlc291cmNlLmNvZGUuaW1hZ2VVcmksXG4gICAgICAgICAgWmlwRmlsZTogcmVzb3VyY2UuY29kZS5mdW5jdGlvbkNvZGVaaXAsXG4gICAgICAgIH0pLnByb21pc2UoKTtcblxuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JMYW1iZGFzUHJvcGVydGllc1VwZGF0ZVRvRmluaXNoKHVwZGF0ZUZ1bmN0aW9uQ29kZVJlc3BvbnNlLCBsYW1iZGEpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzb3VyY2UuY29uZmlndXJhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB1cGRhdGVSZXF1ZXN0OiBBV1MuTGFtYmRhLlVwZGF0ZUZ1bmN0aW9uQ29uZmlndXJhdGlvblJlcXVlc3QgPSB7XG4gICAgICAgICAgRnVuY3Rpb25OYW1lOiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzb3VyY2UuY29uZmlndXJhdGlvbnMuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwZGF0ZVJlcXVlc3QuRGVzY3JpcHRpb24gPSByZXNvdXJjZS5jb25maWd1cmF0aW9ucy5kZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb3VyY2UuY29uZmlndXJhdGlvbnMuZW52aXJvbm1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwZGF0ZVJlcXVlc3QuRW52aXJvbm1lbnQgPSByZXNvdXJjZS5jb25maWd1cmF0aW9ucy5lbnZpcm9ubWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSA9IGF3YWl0IGxhbWJkYS51cGRhdGVGdW5jdGlvbkNvbmZpZ3VyYXRpb24odXBkYXRlUmVxdWVzdCkucHJvbWlzZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JMYW1iZGFzUHJvcGVydGllc1VwZGF0ZVRvRmluaXNoKHVwZGF0ZUZ1bmN0aW9uQ29kZVJlc3BvbnNlLCBsYW1iZGEpO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGlmIHRoZSBjb2RlIGNoYW5nZWQgaXMgdGhlcmUgYW55IHBvaW50IGluIHB1Ymxpc2hpbmcgYSBuZXcgVmVyc2lvblxuICAgICAgaWYgKHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5wdWJsaXNoVmVyc2lvbikge1xuICAgICAgICBjb25zdCBwdWJsaXNoVmVyc2lvblByb21pc2UgPSBsYW1iZGEucHVibGlzaFZlcnNpb24oe1xuICAgICAgICAgIEZ1bmN0aW9uTmFtZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZSxcbiAgICAgICAgfSkucHJvbWlzZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UuYWxpYXNlc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBWZXJzaW9uIHRvIGZpbmlzaCBwdWJsaXNoaW5nXG4gICAgICAgICAgY29uc3QgdmVyc2lvblVwZGF0ZSA9IGF3YWl0IHB1Ymxpc2hWZXJzaW9uUHJvbWlzZTtcblxuICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmFsaWFzZXNOYW1lcykge1xuICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhbWJkYS51cGRhdGVBbGlhcyh7XG4gICAgICAgICAgICAgIEZ1bmN0aW9uTmFtZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZSxcbiAgICAgICAgICAgICAgTmFtZTogYWxpYXMsXG4gICAgICAgICAgICAgIEZ1bmN0aW9uVmVyc2lvbjogdmVyc2lvblVwZGF0ZS5WZXJzaW9uLFxuICAgICAgICAgICAgfSkucHJvbWlzZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHB1Ymxpc2hWZXJzaW9uUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzb3VyY2UudGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB0YWdzVG9EZWxldGU6IHN0cmluZ1tdID0gT2JqZWN0LmVudHJpZXMocmVzb3VyY2UudGFncy50YWdVcGRhdGVzKVxuICAgICAgICAuZmlsdGVyKChbX2tleSwgdmFsXSkgPT4gdmFsID09PSBUYWdEZWxldGlvbi5ERUxFVEUpXG4gICAgICAgIC5tYXAoKFtrZXksIF92YWxdKSA9PiBrZXkpO1xuXG4gICAgICBjb25zdCB0YWdzVG9TZXQ6IHsgW3RhZzogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlc291cmNlLnRhZ3MhLnRhZ1VwZGF0ZXMpXG4gICAgICAgIC5maWx0ZXIoKFtfa2V5LCB2YWxdKSA9PiB2YWwgIT09IFRhZ0RlbGV0aW9uLkRFTEVURSlcbiAgICAgICAgLmZvckVhY2goKFt0YWdOYW1lLCB0YWdWYWx1ZV0pID0+IHtcbiAgICAgICAgICB0YWdzVG9TZXRbdGFnTmFtZV0gPSB0YWdWYWx1ZSBhcyBzdHJpbmc7XG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAodGFnc1RvRGVsZXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhbWJkYS51bnRhZ1Jlc291cmNlKHtcbiAgICAgICAgICBSZXNvdXJjZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmZ1bmN0aW9uQXJuLFxuICAgICAgICAgIFRhZ0tleXM6IHRhZ3NUb0RlbGV0ZSxcbiAgICAgICAgfSkucHJvbWlzZSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRhZ3NUb1NldCkubGVuZ3RoID4gMCkge1xuICAgICAgICBvcGVyYXRpb25zLnB1c2gobGFtYmRhLnRhZ1Jlc291cmNlKHtcbiAgICAgICAgICBSZXNvdXJjZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmZ1bmN0aW9uQXJuLFxuICAgICAgICAgIFRhZ3M6IHRhZ3NUb1NldCxcbiAgICAgICAgfSkucHJvbWlzZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBydW4gYWxsIG9mIG91ciB1cGRhdGVzIGluIHBhcmFsbGVsXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKG9wZXJhdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGEgTGFtYmRhIEZ1bmN0aW9uIGlzIHVwZGF0ZWQsIGl0IGNhbm5vdCBiZSB1cGRhdGVkIGFnYWluIHVudGlsIHRoZVxuICAgKiBgU3RhdGU9QWN0aXZlYCBhbmQgdGhlIGBMYXN0VXBkYXRlU3RhdHVzPVN1Y2Nlc3NmdWxgLlxuICAgKlxuICAgKiBEZXBlbmRpbmcgb24gdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIExhbWJkYSBGdW5jdGlvbiB0aGlzIGNvdWxkIGhhcHBlbiByZWxhdGl2ZWx5IHF1aWNrbHlcbiAgICogb3IgdmVyeSBzbG93bHkuIEZvciBleGFtcGxlLCBaaXAgYmFzZWQgZnVuY3Rpb25zIF9ub3RfIGluIGEgVlBDIGNhbiB0YWtlIH4xIHNlY29uZCB3aGVyZWFzIFZQQ1xuICAgKiBvciBDb250YWluZXIgZnVuY3Rpb25zIGNhbiB0YWtlIH4yNSBzZWNvbmRzIChhbmQgJ2lkbGUnIFZQQyBmdW5jdGlvbnMgY2FuIHRha2UgbWludXRlcykuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHdhaXRGb3JMYW1iZGFzUHJvcGVydGllc1VwZGF0ZVRvRmluaXNoKFxuICAgIGN1cnJlbnRGdW5jdGlvbkNvbmZpZ3VyYXRpb246IEFXUy5MYW1iZGEuRnVuY3Rpb25Db25maWd1cmF0aW9uLCBsYW1iZGE6IEFXUy5MYW1iZGEsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZ1bmN0aW9uSXNJblZwY09yVXNlc0RvY2tlckZvckNvZGUgPSBjdXJyZW50RnVuY3Rpb25Db25maWd1cmF0aW9uLlZwY0NvbmZpZz8uVnBjSWQgfHxcbiAgICAgICAgY3VycmVudEZ1bmN0aW9uQ29uZmlndXJhdGlvbi5QYWNrYWdlVHlwZSA9PT0gJ0ltYWdlJztcblxuICAgIC8vIGlmIHRoZSBmdW5jdGlvbiBpcyBkZXBsb3llZCBpbiBhIFZQQyBvciBpZiBpdCBpcyBhIGNvbnRhaW5lciBpbWFnZSBmdW5jdGlvblxuICAgIC8vIHRoZW4gdGhlIHVwZGF0ZSB3aWxsIHRha2UgbXVjaCBsb25nZXIgYW5kIHdlIGNhbiB3YWl0IGxvbmdlciBiZXR3ZWVuIGNoZWNrc1xuICAgIC8vIG90aGVyd2lzZSwgdGhlIHVwZGF0ZSB3aWxsIGJlIHF1aWNrLCBzbyBhIDEtc2Vjb25kIGRlbGF5IGlzIGZpbmVcbiAgICBjb25zdCBkZWxheVNlY29uZHMgPSBmdW5jdGlvbklzSW5WcGNPclVzZXNEb2NrZXJGb3JDb2RlID8gNSA6IDE7XG5cbiAgICAvLyBjb25maWd1cmUgYSBjdXN0b20gd2FpdGVyIHRvIHdhaXQgZm9yIHRoZSBmdW5jdGlvbiB1cGRhdGUgdG8gY29tcGxldGVcbiAgICAobGFtYmRhIGFzIGFueSkuYXBpLndhaXRlcnMudXBkYXRlRnVuY3Rpb25Qcm9wZXJ0aWVzVG9GaW5pc2ggPSB7XG4gICAgICBuYW1lOiAnVXBkYXRlRnVuY3Rpb25Qcm9wZXJ0aWVzVG9GaW5pc2gnLFxuICAgICAgb3BlcmF0aW9uOiAnZ2V0RnVuY3Rpb24nLFxuICAgICAgLy8gZXF1YXRlcyB0byAxIG1pbnV0ZSBmb3IgemlwIGZ1bmN0aW9uIG5vdCBpbiBhIFZQQyBhbmRcbiAgICAgIC8vIDUgbWludXRlcyBmb3IgY29udGFpbmVyIGZ1bmN0aW9ucyBvciBmdW5jdGlvbiBpbiBhIFZQQ1xuICAgICAgbWF4QXR0ZW1wdHM6IDYwLFxuICAgICAgZGVsYXk6IGRlbGF5U2Vjb25kcyxcbiAgICAgIGFjY2VwdG9yczogW1xuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcjogJ3BhdGgnLFxuICAgICAgICAgIGFyZ3VtZW50OiBcIkNvbmZpZ3VyYXRpb24uTGFzdFVwZGF0ZVN0YXR1cyA9PSAnU3VjY2Vzc2Z1bCcgJiYgQ29uZmlndXJhdGlvbi5TdGF0ZSA9PSAnQWN0aXZlJ1wiLFxuICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgIHN0YXRlOiAnc3VjY2VzcycsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVyOiAncGF0aCcsXG4gICAgICAgICAgYXJndW1lbnQ6ICdDb25maWd1cmF0aW9uLkxhc3RVcGRhdGVTdGF0dXMnLFxuICAgICAgICAgIGV4cGVjdGVkOiAnRmFpbGVkJyxcbiAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuXG4gICAgY29uc3QgdXBkYXRlRnVuY3Rpb25Qcm9wZXJ0aWVzV2FpdGVyID0gbmV3IChBV1MgYXMgYW55KS5SZXNvdXJjZVdhaXRlcihsYW1iZGEsICd1cGRhdGVGdW5jdGlvblByb3BlcnRpZXNUb0ZpbmlzaCcpO1xuICAgIGF3YWl0IHVwZGF0ZUZ1bmN0aW9uUHJvcGVydGllc1dhaXRlci53YWl0KHtcbiAgICAgIEZ1bmN0aW9uTmFtZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZSxcbiAgICB9KS5wcm9taXNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wcmVzcyBhIHN0cmluZyBhcyBhIGZpbGUsIHJldHVybmluZyBhIHByb21pc2UgZm9yIHRoZSB6aXAgYnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJjaGl2ZXJqcy9ub2RlLWFyY2hpdmVyL2lzc3Vlcy8zNDJcbiAqL1xuZnVuY3Rpb24gemlwU3RyaW5nKGZpbGVOYW1lOiBzdHJpbmcsIHJhd1N0cmluZzogc3RyaW5nKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBidWZmZXJzOiBCdWZmZXJbXSA9IFtdO1xuXG4gICAgY29uc3QgY29udmVydGVyID0gbmV3IFdyaXRhYmxlKCk7XG5cbiAgICBjb252ZXJ0ZXIuX3dyaXRlID0gKGNodW5rOiBCdWZmZXIsIF86IHN0cmluZywgY2FsbGJhY2s6ICgpID0+IHZvaWQpID0+IHtcbiAgICAgIGJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgY29udmVydGVyLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQoYnVmZmVycykpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJjaGl2ZSA9IGFyY2hpdmVyKCd6aXAnKTtcblxuICAgIGFyY2hpdmUub24oJ2Vycm9yJywgKGVycjogYW55KSA9PiB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9KTtcblxuICAgIGFyY2hpdmUucGlwZShjb252ZXJ0ZXIpO1xuXG4gICAgYXJjaGl2ZS5hcHBlbmQocmF3U3RyaW5nLCB7XG4gICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgIGRhdGU6IG5ldyBEYXRlKCcxOTgwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSwgLy8gQWRkIGRhdGUgdG8gbWFrZSByZXN1bHRpbmcgemlwIGZpbGUgZGV0ZXJtaW5pc3RpY1xuICAgIH0pO1xuXG4gICAgdm9pZCBhcmNoaXZlLmZpbmFsaXplKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBmaWxlIGV4dGVuc2lvbiBmcm9tIExhbWJkYSBydW50aW1lIHN0cmluZy5cbiAqIFdlIHVzZSB0aGlzIGV4dGVuc2lvbiB0byBjcmVhdGUgYSBkZXBsb3ltZW50IHBhY2thZ2UgZnJvbSBMYW1iZGEgaW5saW5lIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUNvZGVGaWxlRXh0RnJvbVJ1bnRpbWUocnVudGltZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHJ1bnRpbWUuc3RhcnRzV2l0aCgnbm9kZScpKSB7XG4gICAgcmV0dXJuICdqcyc7XG4gIH1cbiAgaWYgKHJ1bnRpbWUuc3RhcnRzV2l0aCgncHl0aG9uJykpIHtcbiAgICByZXR1cm4gJ3B5JztcbiAgfVxuICAvLyBDdXJyZW50bHkgaW5saW5lIGNvZGUgb25seSBzdXBwb3J0cyBOb2RlLmpzIGFuZCBQeXRob24sIGlnbm9yaW5nIG90aGVyIHJ1bnRpbWVzLlxuICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTQ2xvdWRGb3JtYXRpb24vbGF0ZXN0L1VzZXJHdWlkZS9hd3MtcHJvcGVydGllcy1sYW1iZGEtZnVuY3Rpb24tY29kZS5odG1sI2F3cy1wcm9wZXJ0aWVzLWxhbWJkYS1mdW5jdGlvbi1jb2RlLXByb3BlcnRpZXNcbiAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYHJ1bnRpbWUgJHtydW50aW1lfSBpcyB1bnN1cHBvcnRlZCwgb25seSBub2RlLmpzIGFuZCBweXRob24gcnVudGltZXMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG59XG4iXX0=